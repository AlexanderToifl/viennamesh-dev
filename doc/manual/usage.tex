
\section{Usage} 

For examples who to utilize ViennaMesh, have a look at the source files 
of either the main application

\begin{exaipd}
\begin{Verbatim}
src/vmesh.cpp
\end{Verbatim}
\end{exaipd}

or the test applications.

\begin{exaipd}
\begin{Verbatim}
tests/src/
\end{Verbatim}
\end{exaipd}

However, in the following a short glimpse is provided on the capabilities of 
ViennaMesh. 

\subsection{Wrappers}
A input datastructure wrapper approach is used to decouple the 
ViennaMesh internal algorithms from a specific input datastructure.
For example, a wrapper for ViennaGrid datastructures is available.

\begin{lstlisting}{}
typedef viennagrid::domain<viennagrid::config::line_2d>     domain_type;
domain_type domain;

typedef wrapper<viennagrid, domain_type>                    wrapper_type;
wrapper_type    wrapped_input_data(my_bnd_reader);      
\end{lstlisting}

This wrapped input data can now be used as input for a functional meshing chain.

\subsection{Functional Meshing Chain}

ViennaMesh provides specific mesh related functionalities via C++-functors. 
These functors can be chained, meaning that the result of one functor 
can be the input of the next functor and so on. This is commonly known as 
a \texttt{fold} operation.
This, naturally, enables the mapping of an arbitrary meshing flow into 
a C++ expression. Each functor alters the input and passes it on to its 
successor. The functor types are generated by a tag-dispatched mechanism, 
as depicted in the following.

\begin{lstlisting}{}
typedef mesh_generator<cervpt>::type            hull_generator_type;
typedef mesh_adaptor<orienter>::type            orient_adaptor_type;

hull_generator_type hull_generator;
orient_adaptor_type orient_adaptor;
\end{lstlisting}

These instantiated objects can now be utilized in the presented fold manner.
\begin{lstlisting}{}
hull_generator(orient_adaptor(wrapped_input_data));
\end{lstlisting}

The result type of such a chain can be derived from the last applied functor type.
\begin{lstlisting}{}
typedef hull_generator_type::result_type        result_type;
\end{lstlisting}

Hence, the result can be retrieved by
\begin{lstlisting}{}
result_type result = hull_generator(orient_adaptor(wrapped_input_data));
\end{lstlisting}

\subsection{Meta-Selection}

ViennaMesh provides a meta-selection environment which determines the 
best suited mesh generator tool based on specific properties. 

The required properties can be specified by a associative, compile-time container.
\begin{lstlisting}{}
typedef make_map<
   cell_type, algorithm,      
   simplex,   advancing_front
>::type               required_properties;
\end{lstlisting}
Note the associative relation between Line 2 and 3. The key is located 
above the related value entry. Hence, the required properties are that 
the mesh elements are of simplex type, for example, triangles or tetrahedrons.
Additionally, an Advancing Front mesh generation algorithm should be used.

This property type can now be forwarded to the meta-selection utility which 
computes a corresponding mesh generator type.
\begin{lstlisting}{}
typedef compute_mesh_generator<required_properties>::type   computed_mesh_generator_type;
\end{lstlisting}

This type can immediately be used to instantiate the mesh generator functor, 
which again can be used in the already introduced functional meshing chain.
\begin{lstlisting}{}
computed_mesh_generator_type  mesh_generator;
mesh_generator(wrapped_input_data);
\end{lstlisting}


